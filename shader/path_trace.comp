#version 460

#extension GL_GOOGLE_include_directive: require
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable

#include "structs.glsl"

#define PI 3.1415926535897932384626433832

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(constant_id = 0) const uint TEXTURE_COUNT = 1;

layout(push_constant) uniform PushConstant {
    PathTracerPushConstants pc;
};

layout(binding = 0) uniform UniformBuffer
{
    CameraData camera_data;
};
layout(binding = 1) uniform accelerationStructureEXT topLevelAS;
layout(binding = 2, rgba8) uniform restrict readonly image2D input_image;
layout(binding = 3, rgba8) uniform restrict writeonly image2D output_image;
layout(binding = 4) readonly buffer InputPixelBuffer
{
    PixelData input_pixel_data[];
};
layout(binding = 5) writeonly buffer OutputPixelBuffer
{
    PixelData output_pixel_data[];
};
layout(binding = 10) readonly buffer VertexBuffer
{
    AlignedVertex vertices[];
};
layout(binding = 11) readonly buffer IndexBuffer
{
    uint indices[];
};
layout(binding = 12) readonly buffer MaterialBuffer
{
    Material materials[];
};
layout(binding = 13) readonly buffer MeshRenderDataBuffer
{
    MeshRenderData mrd[];
};
layout(binding = 14) readonly buffer ModelMRDIndicesBuffer
{
    uint model_mrd_indices[];
};
layout(binding = 15) uniform sampler2D tex_sampler[TEXTURE_COUNT];
layout(binding = 16) readonly buffer LightBuffer
{
    Light lights[];
};

#include "random.glsl"
#include "spectral.glsl"

bool evaluate_ray(in vec3 ro, in vec3 rd, out float t, out int instance_id, out int geometry_idx, out int primitive_idx, out vec2 bary)
{
    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, topLevelAS, gl_RayFlagsNoneEXT, 0xFF, ro, 0.01, rd, 10000.0);
    rayQueryProceedEXT(rayQuery);
    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
    {
        t = rayQueryGetIntersectionTEXT(rayQuery, true);
        instance_id = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
        geometry_idx = rayQueryGetIntersectionGeometryIndexEXT(rayQuery, true);
        primitive_idx = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
        bary = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
        return true;
    }
    return false;
}

vec4 get_color(uint mrd_idx, Vertex v)
{
    if (mrd[mrd_idx].mat_idx < 0) return v.color;
    Material m = materials[mrd[mrd_idx].mat_idx];
    if (m.base_texture >= 0)
    {
        return texture(tex_sampler[materials[mrd[mrd_idx].mat_idx].base_texture], v.tex);
    }
    else if (length(m.base_color) > 0.0)
    {
        return m.base_color;
    }
    else if (length(m.emission) > 0.0)
    {
        return m.emission;
    }
    else
    {
        return vec4(0.0, 0.5, 0.0, 1.0);
    }
}

Vertex interpolate_attributes(uint mrd_idx, int primitive_idx, vec2 bary)
{
    Vertex v0 = unpack_vertex(vertices[indices[mrd[mrd_idx].indices_idx + primitive_idx * 3]]);
    Vertex v1 = unpack_vertex(vertices[indices[mrd[mrd_idx].indices_idx + primitive_idx * 3 + 1]]);
    Vertex v2 = unpack_vertex(vertices[indices[mrd[mrd_idx].indices_idx + primitive_idx * 3 + 2]]);
    Vertex v;
    v.normal = normalize((1.0 - bary.x - bary.y) * v0.normal + bary.x * v1.normal + bary.y * v2.normal);
    v.color = (1.0 - bary.x - bary.y) * v0.color + bary.x * v1.color + bary.y * v2.color;
    v.tex = (1.0 - bary.x - bary.y) * v0.tex + bary.x * v1.tex + bary.y * v2.tex;
    return v;
}

void main()
{
    ivec2 viewport_size = imageSize(output_image);
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x > viewport_size.x || pixel.y > viewport_size.y) return;
    rng_state = (pixel.y * viewport_size.x + pixel.x + (pc.sample_count + 3) * viewport_size.x * viewport_size.y);
    vec2 jitter = vec2(pcg_random_state(), pcg_random_state()) - 0.5;
    vec2 norm_pixel = ((vec2(pixel) + jitter) / vec2(viewport_size) - 0.5) * camera_data.sensor_size;
    vec3 p = camera_data.pos;
    vec3 dir = normalize(-camera_data.w * camera_data.focal_length + norm_pixel.x * camera_data.u + norm_pixel.y * camera_data.v);
    vec4 out_color = vec4(0.0, 0.0, 0.0, 0.0);
    uint wavelength = 380 + uint(pcg_random_state() * 400.0);
    float t = 0.0;
    int instance_id = 0;
    int primitive_idx = 0;
    int geometry_idx = 0;
    vec2 bary = vec2(0.0);
    if (evaluate_ray(p, dir, t, instance_id, geometry_idx, primitive_idx, bary))
    {
        uint mrd_idx = model_mrd_indices[instance_id] + geometry_idx;
        Vertex v = interpolate_attributes(mrd_idx, primitive_idx, bary);
        out_color = get_color(mrd_idx, v);
    }
    else
    {
        out_color = vec4(0.0, 0.0, 0.5, 1.0);
    }
    out_color *= wavelength_to_rgba(wavelength);
    if (pc.sample_count > 0)
    {
        out_color = input_pixel_data[pixel.y * viewport_size.x + pixel.x].col * float(pc.sample_count - 1) / float(pc.sample_count) + out_color / float(pc.sample_count);
    }
    output_pixel_data[pixel.y * viewport_size.x + pixel.x].col = out_color;
    imageStore(output_image, ivec2(pixel.x, viewport_size.y - pixel.y), out_color);
}
